module Protocol

use export estatica.BfExtendCompute

(* No Coq usam um par IP/porta, mas aqui preferem usar apenas um inteiro; no final de contas, dá no mesmo. *)
 type address = int

(* Os diversos tipos de mensagem que podemos ter e que, no final do dia, vão representar os componentes que podemos enviar. *)
 type message =
      | AddrMsg (list address)
      | ConnectMsg
      | BlockMsg block
      | TxMsg tx
      | InvMsg (list hash)
      | GetDataMsg hash

  (* Fazer o unpack das mensagens de blocos. *)
  function msg_block (m:message) : block =
    match m with
    | BlockMsg b -> b
    | _ -> gBlock
    end
  
  (* Fazer o unpack das mensagens de hashes. *)
  function msg_hashes (m:message) : list hash =
    match m with
    | InvMsg sh -> sh
    | GetDataMsg h -> Cons h Nil
    | _ -> Nil
    end
  
  (* Transação interna. *)
  type intnlTx =
       | TxT tx
       | MintT

  (* Pacote com a mensagem. *)
  type packet = { src : address ; dst : address ; msg : message }
  
  val predicate eqp (p1:packet) (p2:packet)
  (* ensures { result <-> p1 = p2 } *)
  ensures { result <-> p1.src = p2.src /\ p1.dst = p2.dst /\ p1.msg = p2.msg }

  (* "Empacotar" uma mensagem. *)
  function mkP (s d:address) (m:message) : packet
    = { src=s ; dst=d ; msg=m } 

(* Definition ToSend := seq Packet. *)

  (* Funções de emissão de pacotes: emitir um, mais do que um, ou nenhum. *)
  let constant emitZero : list packet = Nil
  function emitOne (p :packet) : list packet = Cons p Nil
  function emitMany (pkts :list packet) : list packet = pkts
  
  (* Envia a mesma mensagem para uma lista de destinos. *)
  let rec function emitBroadcast (from:address) (dsts:list address) (m:message) : list packet =
    ensures { forall p :packet.  LMem.mem p result -> p.src=from /\ LMem.mem p.dst dsts /\ p.msg=m }
    ensures { forall d :address. LMem.mem d dsts -> LMem.mem { src=from ; dst=d ; msg=m } result }
  match dsts with
  | Nil -> Nil
  | Cons d t -> Cons { src=from ; dst=d ; msg=m } (emitBroadcast from t m)
  end
  
  (* Representa um nodo na blockchain. *)
  type state = { id : address ; peers : list address ; blockTree : bforest ; txPool : txpool }

  (* Empacota nodos para a blockchain. *)
  function mkSt  (n:address) (prs:list address) (bf:bforest) (txp:txpool) : state
    = { id=n ; peers=prs ; blockTree=bf ; txPool=txp }

  (* Todos os estados devem ter os seus hashes válidos, devem conter o gblock e todos os nodos que conhecem devem ser únicos. *)
  (*Cof do Coq*)
  predicate inv (st:state) = validH st.blockTree /\ hasInit st.blockTree /\ distinct st.peers              

 (* Estado inicial de qualquer nodo no sistema de blockchain. *)
  let ghost function init (n:address) : state
  =  { id=n ; peers=Cons n Nil ; blockTree=add (hashB gBlock) gBlock empty ; txPool=Nil }

  (* Garante que os resultados da lista de pares são únicos. *)
  val function undup (l:list address) : list address
    ensures { forall a :address. LMem.mem a result <-> LMem.mem a l }
    ensures { distinct result }
  
  (* Vai filtrar todos os endereços da primeira lista que aparecem na segunda lista. *)
  let rec ghost function filterPeers (al:list address) (peers:list address) : list address
    ensures { forall a :address. LMem.mem a result <-> LMem.mem a al /\ not LMem.mem a peers }
  = match al with
    | Nil -> Nil
    | Cons a al' -> if LMem.mem a peers then filterPeers al' peers
      	     	    else Cons a (filterPeers al' peers)
    end

  (* Criar uma lista de pacotes de mensagens de conexão do nodo cujo endereço é id para cada um dos nodos cujos endereços estão 
  na lista al. *)
  let rec ghost function makeConnectPkts (al:list address) (id:address) : list packet
    ensures { forall p :packet. LMem.mem p result -> exists a :address. LMem.mem a al /\ p = mkP id a ConnectMsg }
    ensures { forall a :address. LMem.mem a al -> LMem.mem (mkP id a ConnectMsg) result }
  = match al with
    | Nil -> Nil
    | Cons a al' -> Cons (mkP id a ConnectMsg) (makeConnectPkts al' id)
    end
  
  (* Filtra todas as transações que não são válidas em bc. *)
  let rec ghost function filterTxBC (txl:txpool) (bc:chain) : txpool
    ensures { forall t :tx. LMem.mem t result <-> LMem.mem t txl /\ txValid t bc }
  = match txl with
    | Nil -> Nil
    | Cons t txl' -> if txValid t bc then Cons t (filterTxBC txl' bc)
      	     	     else filterTxBC txl' bc
    end
  
  (* Vamos obter uma lista dos hashes das transações dadas. *)
  let rec ghost function mapTxH (txl:txpool) : list hash
    ensures { forall h :hash. LMem.mem h result -> exists t :tx. LMem.mem t txl /\ h = hashT t }
    ensures { forall t :tx. LMem.mem t txl -> LMem.mem (hashT t) result }
  = match txl with
    | Nil -> Nil
    | Cons t txl' -> Cons (hashT t) (mapTxH txl')
    end
  
  (* Filtrar todos os hashes de lh que também pertencem a filtH. *)
  let rec ghost function filterH (lh:list hash) (filtH:list hash) : list hash
    ensures { forall h: hash. LMem.mem h result <-> LMem.mem h lh /\ not LMem.mem h filtH }
  = match lh with
    | Nil -> Nil
    | Cons h lh' -> if LMem.mem h filtH then filterH lh' filtH
      	     	    else Cons h (filterH lh' filtH)
    end
  
  (* Vamos obter uma lista de pacotes cujas mensagens são todas de um só nodo, para outro nodo, tendo tantas mensagens 
  quantos hashes de lh. *)
  let rec ghost function mapHPkt (lh:list hash) (id:address) (from:address) : list packet
    ensures { forall p :packet. LMem.mem p result -> exists h :hash. LMem.mem h lh /\ p = mkP id from (GetDataMsg h) }
    ensures { forall h :hash. LMem.mem h lh -> LMem.mem (mkP id from (GetDataMsg h)) result }
  = match lh with
    | Nil -> Nil
    | Cons h lh' -> Cons (mkP id from (GetDataMsg h)) (mapHPkt lh' id from) 
    end
  
  (* Vamos filtrar todas as transações cujos hashes são diferentes de h. *)
  let rec ghost function filterTxH (txl:txpool) (h:hash) : txpool
    ensures { forall t :tx. LMem.mem t result <-> LMem.mem t txl /\ hashT t = h }
  = match txl with
    | Nil -> Nil
    | Cons t txl' -> if eqh (hashT t) h then Cons t (filterTxH txl' h)
      	     	     else filterTxH txl' h
    end

  (* Verifica que não há colisões com um bloco a adicionar e bt do nodo. *)
  predicate procMsg_enbld (st:state) (address) (m:message) (time)  = 
    match m with | BlockMsg b -> noCollision st.blockTree b
    	       	 | _ -> true
    end

  let ghost function procMsg (st:state) (from:address) (m:message) (ts:time): (st' :state, lp :list packet)
    
    (* É necessário que, se a mensagem for para adicionar um bloco, não haja colisões com esse bloco na bt do nodo. *)
    requires { procMsg_enbld st from m ts }

    (* procMsg_id_constant: garante que o endereço do nodo a usar a função é constante. *)
    ensures  { st'.id = st.id }

    (* procMsg_validH: se os hashes da bt do nodo eram válidos, então, depois da acção da função, a sua nova bt também o será. *)
    ensures  { validH st.blockTree -> validH st'.blockTree }

    (* procMsg_has_init_block: se os hashes da bt do nodo eram válidos e se este nodo tem o gblock, então a sua nova bt também 
    terá o gblock. *)
    ensures  { validH st.blockTree -> hasInit st.blockTree -> hasInit st'.blockTree }
    
    (* procMsg_peers_uniq: se a lista de endereços dos nodos que o nodo conhece não tem repetições, então, depois da acção da função, 
    também não terá repetições. *)                 
    ensures  { distinct st.peers -> distinct st'.peers }                                                 
    
    ensures  { let bf = st.blockTree in let bf' = st'.blockTree in
    	       match m with                                                                          (* Se a mensagem recebida for um BlockMsg b, então: *)
    	       
             | BlockMsg b -> (hasBlock st.blockTree b -> st'.blockTree = st.blockTree) /\          (* procMsg_known_block_nc_blockTree: se b já pertencer à bt do nodo, então a bt do novo estado interno do nodo é igual à anterior. *)        
               	 	       (hasInit bf -> LMem.mem b (bfChain bf) -> bfChain bf' = bfChain bf) /\    (* procMsg_known_block_nc_btChain: se b já pertencer à maior chain da bt do nodo, então a maior chain da bt do novo estado interno do nodo é igual à chain do estado interno anterior. *)
			       bf' = bfExtend bf b /\                                                                (* procMsg_block_btExtend_bt: se b não pertencer à bf, então a bf do próximo estado interno do nodo será apenas a bf anterior estendida com b. *)
			       bfChain bf' = bfChain (bfExtend bf b)                                                 (* procMsg_block_btExtend_btChain: se b não pertencer à bf, então a maior chain da bf do próximo estado interno do nodo será apenas a maior chain da bf do estado interno anterior estendida com b. *)
                                                                                                   (* Se a mensagem recebida não for um BlockMsg b então: *)
             
             | _ -> st'.blockTree = st.blockTree /\                                                (* procMsg_non_block_nc_blockTree: as bt do estado interno do nodo actual e do próximo estado interno do nodo serão iguais. *)
             bfChain st'.blockTree = bfChain st.blockTree                                          (* procMsg_non_block_nc_btChain: as maiores chains da bt do estado interno do nodo actual e do próximo estado interno do nodo serão iguais. *)
	       	end }
    
    ensures  { inv st -> inv st' } (* A invariante de estado prevalece com as alterações no estado interno de um nodo. *)

  = match m with
    (** Quando recebemos este tipo de mensagem, ou não fazemos nada — pois o endereço do nodo que nos enviou a mensagem já é conhecido —,
    ou, se este não for conhecido, adicionamo-lo aos nossos peers e enviamos uma mensagem de *connect* para o nodo que nos enviou a
    mensagem, bem como uma mensagem *addrmsg* com todos os endereços que conhecemos aos nodos cujos endereços já conhecíamos antes
    de receber a mensagem de *connect*. O estado do nodo é atualizado para incluir mais um endereço na sua lista de endereços. *)
    | ConnectMsg -> if LMem.mem from st.peers then (st, emitZero)
      		    else let updP = undup (Cons from st.peers)
		    	 in  (mkSt st.id updP st.blockTree st.txPool , 
                              emitOne (mkP st.id from ConnectMsg) ++ emitBroadcast st.id st.peers (AddrMsg updP))

    (** Vamos primeiro retirar todos os endereços que já conhecemos. Se os conhecermos todos, não fazemos nada;
    se houver algum que não conhecemos, vamos criar mensagens de *connect* para cada um desses nodos.
    Depois, enviamos todas essas mensagens de *connect* e enviamos, para todos os nodos cujos endereços já conhecíamos antes de
    receber a mensagem de *Addr*, uma nova mensagem *Addr* com todos os nodos que passámos a conhecer após a receção.
    O estado do nodo é então atualizado com todos os novos endereços. *)
    | AddrMsg knownPeers -> let newP = filterPeers knownPeers st.peers
                            in if is_nil newP then (st, emitZero)
			       else let connects = makeConnectPkts newP st.id
			       	    in let updP = undup (st.peers ++ newP)
				    in (mkSt st.id updP st.blockTree st.txPool,
				        emitMany connects ++ emitBroadcast st.id st.peers (AddrMsg updP))
		
    (** Vamos adicionar o novo bloco à bt do nodo, garantindo que nenhuma transação do nodo é inválida face à nova maior *chain*.
    Depois, obtemos uma lista com todos os hashes dos blocos da nova bt, juntamente com todos os hashes do novo conjunto de transações.
    Por fim, enviamos uma mensagem *inv* com essa lista de hashes para todos os nodos cujo endereço conhecemos.
    O estado do nodo é atualizado com a nova bt e o novo conjunto de transações. *)
    | BlockMsg b -> let newBf = bfExtend st.blockTree b
      	       	    in let newPool = filterTxBC st.txPool (bfChain newBf)   
		    in let ownHashes = dom newBf ++ mapTxH newPool 
		    in (mkSt st.id st.peers newBf newPool,
		        emitBroadcast st.id st.peers (InvMsg ownHashes))

    (** Vamos adicionar a nova transação à lista de transações do nodo.
    Depois, obtemos uma lista com todos os hashes dos blocos da bt do nodo, assim como os hashes do novo conjunto de transações.
    Por fim, enviamos uma mensagem *inv* com essa lista de hashes para todos os nodos cujo endereço conhecemos.
    O estado do nodo é atualizado com o novo conjunto de transações. *)		    
    | TxMsg tx -> let newPool = tpExtend st.txPool st.blockTree tx
      	       	  in let ownHashes = dom st.blockTree ++ mapTxH newPool 
		  in (mkSt st.id st.peers st.blockTree newPool,
		      emitBroadcast st.id st.peers (InvMsg ownHashes))
		
    (** Vamos ao nosso conjunto de hashes — constituído pelos hashes dos blocos e das transações do nodo —,
    e retiramos desse conjunto de hashes recebido todas as que o nodo já possui.
    Em seguida, enviamos ao nodo remetente várias mensagens *getdata*, uma para cada hash que o nodo recetor tenha e o remetente não.
    O estado do nodo mantém-se inalterado. *)
    | InvMsg peerHashes -> let ownHashes = dom st.blockTree ++ mapTxH st.txPool
      	     		   in let newH = filterH peerHashes ownHashes 
			   in let gets = mapHPkt newH st.id from 
			   in (st, emitMany gets)
    
    (** Se a mensagem é do nodo para si próprio, é para ser ignorada; o estado do nodo mantém-se igual.
    Depois, procuramos na bt do nodo o bloco cuja hash seja igual à enviada. Se o bloco for encontrado,
    o nodo envia-o ao remetente. Caso contrário, procura essa hash no conjunto de hashes das suas transações.
    Se a transação for encontrada aí, envia-a ao remetente; caso contrário, não faz nada. *)
    | GetDataMsg h -> if from=st.id then (st, emitZero)
      		      else let matchingBlock = get_block st.blockTree h
		           in if not eqb matchingBlock gBlock (*getblock retorna o gblock se nada encontrar*)
			        then (st, emitOne (mkP st.id from (BlockMsg matchingBlock)))
			      	else let matchingTxs = filterTxH st.txPool h 
			      	     in if not is_nil matchingTxs
				          then  (st, emitOne (mkP st.id from (TxMsg (hd matchingTxs))))
        				  else  (st, emitZero)

    end
  
  (* Vai retornar true se tr não for MinT, se não conseguir gerar um bloco, e se não houver colisões entre o bloco gerado e a bt do nodo. *)
  predicate procInt_enbld (st:state) (tr:intnlTx) (ts:time) =
    let bc = bfChain st.blockTree
    in match tr with
       | MintT -> match (genProof bc (filterTxBC st.txPool bc) ts) with
	          | Some (txs, pf) -> noCollision st.blockTree { prev=hashB (last bc) ; txs=txs ; pf=pf } 
    	       	  | _ -> true
		  end
       | _ -> true
    end 

  let ghost function procInt (st:state) (tr:intnlTx) (ts:time) : (st' :state, lp :list packet)
    
    requires { procInt_enbld st tr ts }

    (* procInt_id_constant: o endereço do nodo é constante. *)
    ensures  { st'.id = st.id }

    (* procInt_validH: se os hashes da bt do nodo eram válidos, então, após a acção da função, a nova bt também o será. *)     
    ensures  { validH st.blockTree -> validH st'.blockTree }

    (* procInt_has_init_block: se os hashes da bt do nodo eram válidos e se este nodo tem o gblock, então a nova bt também terá 
    o gblock. *)                                            
    ensures  { validH st.blockTree -> hasInit st.blockTree -> hasInit st'.blockTree }

    (* procInt_peers_uniq: se a lista de endereços de nodos que que o nodo conhece não tem repetições então depois da ação da
    função tbm não terá repetições*)               
    ensures  { distinct st.peers -> distinct st'.peers }                                                 
    

    ensures  { inv st -> inv st' } (* A invariante de estado prevalece com as alterações no estado interno de um nodo. *)
 
 = match tr with
    
    (* Quando um nodo produz uma transação, esta será propagada para todos os seus pares — ou seja, todos os nodos cujos endereços são conhecidos. *)
    | TxT tx -> (st, emitBroadcast st.id st.peers (TxMsg tx))
    
    (** Quando um nodo tenta minerar o próximo bloco, precisa da sua maior *bc* e de todas as transações válidas nessa *bc*.
    De seguida, é utilizada a função de geração de uma prova para o bloco. Se esta não for bem-sucedida, o nodo não emite nada.
    Caso seja bem-sucedida, o nodo tenta minerar o próximo bloco na *bc*. Se este bloco não for válido na *bc* do nodo,
    ele é descartado e nada é emitido. Caso contrário, se for válido, a *bt* do nodo é estendida com o novo bloco,
    o conjunto de transações do nodo é actualizado para remover todas as transações que deixaram de ser válidas para a nova *bc*,
    e o bloco é emitido em *broadcast* para todos os nodos cujos endereços são conhecidos. *)
    | MintT -> let bc = bfChain st.blockTree
      	       in let allowedTxs = filterTxBC st.txPool bc 
	       in match (genProof bc allowedTxs ts) with
	          | Some (txs, pf) -> let prevBlock = last bc
		      	       	      in let b = { prev=hashB prevBlock ; txs=txs ; pf=pf } 
				      in if valid_chain_block bc b then
				           let newBf = bfExtend st.blockTree b
					   in let newPool = filterTxBC st.txPool (bfChain newBf)
					   in (mkSt st.id st.peers newBf newPool,
					       emitBroadcast st.id st.peers (BlockMsg b))
				         else (st, emitZero)
	          | None -> (st, emitZero)
		  end
    end

end


module ConsensusNetwork

  use export Protocol
  
  (*sistema de blockchain*)
  type blockchain_sistem = fmap address state

  (*Conf*)
  type world = { lSt : blockchain_sistem ; inFlightMsgs : list packet ; consumedMsgs : list packet }
  
  (*os nodos são sempre os mesmos em todos os mundo apenas o seu estado é alterado*)
  axiom constant_nodes: forall a:address, w1 w2: world. mem a w1.lSt <-> mem a w2.lSt 
  
  
  (*invariante do sistema de blockchain*)
  (*invariante provada no ficehiro Network*)
  predicate inv_glbl (w:world) =
    (forall a :address. mem a w.lSt -> let st = find a w.lSt in inv st /\ st.id = a)
    
    /\
    
    ( forall p :packet. LMem.mem p w.inFlightMsgs \/ LMem.mem p w.consumedMsgs -> mem p.src w.lSt /\ mem p.dst w.lSt ) (*não podemos enviar pacotes para nodos fora do sistema*)

  (*função que elimina pacotes  das listas das mensaguens lidas e a serem enviadas*)
  let rec ghost function remP (p:packet) (lp:list packet) : list packet
  
    ensures {forall pack :packet. LMem.mem pack result -> LMem.mem pack lp }
    ensures {forall pack :packet. LMem.mem pack lp -> pack <> p -> LMem.mem pack result}
    ensures {forall l1 l2: list packet. (not (LMem.mem p l1) /\ lp = l1 ++ (Cons p Nil) ++ l2) -> result = l1 ++ l2 }

    = match lp with
      | Nil -> Nil
      | Cons pack lpt -> if eqp pack p then lpt else Cons pack (remP p lpt)
  end

  (* garantir que o destinatário é o allowed e que pertence no sistema, temos também de garantir que o pacote está nas mensagens a
  enviar bem como verifica que não á colisões com um bloco a adicionar e bt do nodo *)
  predicate procMsg_enbld_glbl (w:world) (allowed:address) (ts:time) (p:packet) = 
    mem allowed w.lSt /\ p.dst = allowed /\ LMem.mem p w.inFlightMsgs /\ mem p.src w.lSt
      /\ procMsg_enbld (find p.dst w.lSt) p.src p.msg ts 

  (*faz com que um nodo do sistema realise um passo de ler uma mensaguem e enviar mensaguens para os outros*)
  let ghost function procMsg_glbl (w:world) (allowed:address) (ts:time) (p:packet) : world
    
    requires { procMsg_enbld_glbl w allowed ts p }

    ensures  {inv_glbl w -> inv_glbl result } (*a invariante de mundo é sempre verdadeira*)
  
  = let (st',msgs) = procMsg (find (p.dst) w.lSt) p.src p.msg ts (*criar o novo estado do nodo que recebeu a mensagem*)
    in { lSt = add p.dst st' w.lSt ; (*atualizar todos os nodos do sistema*)
       	 inFlightMsgs = (remP p w.inFlightMsgs) ++ msgs; (*a colocar todas as mensaguem produzidas depois de interpretar a mensaguem e a retirar a mensaguem lida*)
	 consumedMsgs = w.consumedMsgs ++ (Cons p Nil) } (*pomos a mensagem lida na lista da mensagem lidas*)


  (* garantir que o proprio nodo é o allowed e que pertence no sistema e
  vai returnar true se ou tr não é MinT, se não consegui gerar um bloco e se não aja colisões com o bloco gerado e a bt do nodo*)
  predicate procInt_enbld_glbl (w:world) (allowed:address) (ts:time) (tr:intnlTx) =
    mem allowed w.lSt /\ procInt_enbld (find allowed w.lSt) tr ts
    
  let ghost function procInt_glbl (w:world) (allowed:address) (ts:time) (tr:intnlTx) : world
    
    requires { procInt_enbld_glbl w allowed ts tr }

    ensures  { inv_glbl w -> inv_glbl result } (*a invariante de mundo é sempre verdadeira*)
  
  = let (st',msgs) = procInt (find allowed w.lSt) tr ts
    in { lSt = add allowed st' w.lSt ; (*atualizar o mapa de nodos com o seu novo estado interno*)
       	 inFlightMsgs = msgs ++ w.inFlightMsgs ; (*colucar as mensaguens produzidas na lista delas*)
	 consumedMsgs = w.consumedMsgs }(*nenhuma mensaguem é consumida*)

  inductive stepind world world =

  | deliver : forall w :world, allowed :address, ts :time, p :packet. (*receber uma mensaguem e ela*)
                procMsg_enbld_glbl w allowed ts p ->
		  stepind w (procMsg_glbl w allowed ts p)
  
  | intern : forall w :world, allowed :address, ts :time, tr :intnlTx. (*fazer uma trasição interna*)
                procInt_enbld_glbl w allowed ts tr ->
		  stepind w (procInt_glbl w allowed ts tr)


  let ghost predicate step (st1:world) (st2:world) = stepind st1 st2 
  
  (*estado inicial do mundo*)
  predicate initWorld_p (w:world) =
    (forall a :address. mem a w.lSt -> find a w.lSt = init a)
    /\ is_nil w.inFlightMsgs
    /\ is_nil w.consumedMsgs 
    
  let ghost predicate initWorld (w:world) = initWorld_p w

  (* Proof of inductiveness*)
  clone export inductiveness.Inductiveness with
    type world,
    predicate inv=inv_glbl,
    val step,
    val initWorld

end